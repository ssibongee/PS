# LIS



* LIS는 Longest Increasing Subsequence의 약자로 주어진 수열에서 가장 긴 증가하는 부분 수열을 찾는 문제이다. 
* LIS를 해결하는 방법은 크게 두 가지로 나누어진다.
  * 다이나믹 프로그래밍을 이용하는 방법
  * 이분탐색을 이용하는 방법
* 일반적으로 문제에서 주어진 N이 5000이하라면 DP로 해결할 수 있지만 그렇지 않은 경우 TLE가 발생할 수 있다.
* 때문에 주어진 N의 크기를 잘 살펴서 각각의 방법을 선택하면 된다.



## 다이나믹 프로그래밍을 이용하여 LIS를 구하는 방법



* 다이나믹 프로그래밍 (이하 DP)으로 문제를 하결하는 과정은 크게 두 단계로 나누어진다.
* 주어진 데이터를 처음부터 끝까지 순회하면서 만들어질 수 있는 최장 증가 수열에 어느 지점에 들어갈 수 있는지 찾는다.
* 만약 자신보다 큰 원소가 그 지점에 존재하면 해당 원소를 삭제하고 자기자신으로 갱신한다.



* 초기화

```java
int N; 														// 주어진 데이터의 크기 
int max = 0, maxIndex = 0;        // 최대로 만들수 있는 LIS길이를 저장할 변수max와 해당 원소의 index를 저장할 maxIndex

int[] arr = new int[N]; 					// 입력으로 주어진 수열 arr
int[] dp = new int[N];						// i번째 원소를 포함한 최장 LIS 길이를 저장할 배열 
int[] prev = new int[N];          // 경로를 트래킹하기 위해서 이전 인덱스를 저장하는 배열

Arrays.fill(prev, -1);            // 초기 경로는 -1로 초기화한다.

```



* 최장 증가 수열 구하기 

```java
for(int i = 0; i < n; i++) {
  dp[i] = 1;                      // 모든 원소의 처음 LIS길이는 자기 자신인 1을 나타낸다.
  for(int j = 0; j < i; j++) {
    if(a[j] < a[i] && dp[i] < dp[j] + 1) {
      dp[i] = dp[j] + 1;          // 0번째 부터 자기자신 사이의 원소 중에서 작은 원소가 존재하고 해당 원소가 만들 수 있는 LIS 길이가
                                  // 자기자신이 만들수 있는 LIS길이보다 길거나 같은 경우 자기자신의 LIS길이를 해당 원소의 LIS
                                  // 길이보다 1증가시킨다.
      prev[i] = j;                // 자기자신까지 만들 수 있는 LIS중에서 자신 이전의 원소를 자신보다 작은 원소로 초기화 한다.
    }
    if(max < dp[i]) {             // 최대로 만들 수 있는 LIS길이와 그 때의 인덱스를 갱신한다.
      max = dp[i];
      maxIndex = i;
    }
  }
}
```



## 관련 문제

* [가장 긴 증가하는 부분 수열](https://www.acmicpc.net/problem/11053)
* [가장 긴 증가하는 부분 수열 4](https://www.acmicpc.net/problem/14002)