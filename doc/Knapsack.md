### Knapsack



* 배낭문제는 다이나믹 프로그래밍의 대표 유형중 하나이다.
* 배낭 문제는 일반적으로 배낭의 무게와 넣을 수 있는 물건들의 무게와 가치가 주어진다.
* 주어진 정보를 바탕으로 가방에 물건들의 가치의 합이 최대가 되는 결과를 찾는 것이다.



<br>

### 배낭 문제 해결하기 



* 배낭문제는 2차원 배열을 이용하여 문제를 해결한다. 
* 배열의 인덱스로 사용하는 `i` 와 `j` 는 각각 물건의 번호와 물건을 넣었을 때 배낭의 무게를 의미한다.

* 배낭에 물건을 넣을 때 이 값을 갱신시킬 것인지 아닌지를 점화식으로 나타낼 수 있다.
* `dp[i][j] = max(dp[i-1][j], dp[i-1][j - weights[i]] + values[i]) `
  * `i` 번째 물건을 무게가 `j` 인 배낭에 넣으려고 할 때를 고려한다.
  * 용량이 `j` 인 배낭에 물건을 넣지 않았을 때의 가치합의 최대값은 `dp[i-1][j]` 이다.
  * 즉, `i-1` 번째 물건까지 살펴보았을 때 가치합의 최대 값이다.
  * 용량이 `j` 인 배낭에 물건을 넣었을 때의 상황은 `dp[i-1][j - weights[i]] + values[i]` 이다.
  * 즉, `i-1` 번째 물건까지 살펴보았고 그 때의 배낭의 용량이 `j - weights[i]` 였을 때 새롭게 `i` 번째 물건을 넣은 상황이다.
  * 위의 두 경우 중에서의 최대가 되는 값을 선택한다.



<br>



```java
for(int i = 1; i <= N; i++) {                 // 물건의 개수는 총 N개이다.
  for(int j = 1; j <= K; j++) {               // 배낭의 최대 무게는 K이다.
    if(j < weights[i]) {                      // 현재 물건의 무게가 현재 배낭의 무게가 될 수 있는 무게를 초과한다면 넣지 않는다.
      dp[i][j] = dp[i-1][j];
    } else {
      dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j - weights[i]] + values[i]]);
    }
  }
}
```



* 위의 과정을 통해 최종적으로 구한 `dp[N][K]` 값이 배낭에 넣을 수 있는 물건들의 가치의 합이 최대가 되는 값이다.



<br>



### 배낭문제를 1차원으로 해결하기



* 배낭문제는 접근 방법을 반대로해서 이를 1차원으로 해결할 수 있다.
* 이전의 접근방법이 가방 용량을 1부터 K까지 작은 쪽부터 큰 쪽까지 순차적으로 살펴보았다.
* 이를 최적화 하기 위해서는 가방 용량을 K에서부터 1까지 큰 쪽에서부터 작은쪽으로 살펴보아야 한다.
  * 배낭무게가 K일 때 부터 1이될 때 까지 첫번째 물건을 넣을 수 있는지 확인한다.
  * 그 다음 마찬가지로 해당 가방에 물건을 넣었을 때와 넣지 않았을 때의 가치의 합이 최대가 되는 것을 선택한다.
  * 이를 점화식으로 세우면 다음과 같다.
  * `dp[j] = max(dp[j], dp[j - weights[i] + valeus[i])`



<br>



```java
for(int i = 1; i <= N; i++) {
  for(int j = K; j >= 1; j--) {
    if(j >= weights[i]) {
      dp[j] = Math.max(dp[j], dp[j-weights[i]] + values[i]);
    }
  }
}
```





### 관련 문제

* [평범한 배낭](https://www.acmicpc.net/problem/12865)
* [앱](https://www.acmicpc.net/problem/7579)

